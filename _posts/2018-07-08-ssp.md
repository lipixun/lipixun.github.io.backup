---
layout: post
title: "论文快读 - More Effective Distributed ML via a Stale Synchronous Parallel Parameter Server"
category: 论文快读
description: "机器学习架构"
date: 2018-07-08
tags: [paper,ml]
comments: true
mathjax: true
---

[原文请狂击这里](http://www.cs.cmu.edu/~seunghak/SSPTable_NIPS2013.pdf)

## 概述

在大规模的数据集上很难避免并行的训练模型，想象一下100T的训练数据一个worker是很难在一个合理的时间里完成训练的。

并行训练给机器学习带来了一些新的挑战，除了基本的数据流、运维调度等等方面以外，有一个重要的问题就是梯度更新的方法。无论是传统的SGD还是各种新的优化方法基本都是基于batch更新的，并行训练时各个worker处理分配到这个worker的batch，反向传播之后push梯度，然后pull最新的参数再处理下一个batch。这个时候有一个问题是当一个worker特别慢的时候，这个worker push的梯度是使用一个非常旧的参数计算出来的，这个梯度可能已经不适合当下的参数了甚至会起到反作用。当系统中的worker越多时快慢节点的问题就愈发的严重了。

本文就提出了一种方法来调度worker在效率和正确性上做一个良好的权衡。

## 方法

常见的并行训练的模式有两种：

* 同步，各个worker并行训练，每次更新梯度时都等待所有worker都完成了本次迭代的计算，然后一起开始下一次迭代。
* 异步，各个worker并行训练，各自处理各自的数据不等待其他任何worker

以上两个方案可以看到都是针对一个特性去优化的：同步方法带来了绝对的正确性，但是效率是比较差的——一次迭代的时间取决于最慢的节点。异步方法的性能是最好的，但是带来的问题是上文中提到的梯度正确性的问题。

本文提出的SSP方案其实是两种方案的权衡，同时兼顾了性能和正确性。论文原文很长，这个方案本身的描述却可以非常短：

各个worker并行训练，每次进行下一次迭代时判断一下自己的迭代比整个系统中最慢的节点的迭代快多少个step，如果达到一个阈值就进入等待状态直到step小于阈值开始下一次计算。

在这个方法下整个系统中最快的节点比最慢的节点最快不超过阈值个step，同时考虑到了性能和正确性，同时实现也非常容易。

## 问题

* 慢节点拖累系统的问题仍然存在，这种方法本质上没有解决慢节点对系统性能造成严重影响的问题。慢节点可以简单的分为两种情况：环境相关、数据相关。环境相关问题的慢节点可以通过对慢节点进行计数，如果一个节点一直处于慢节点状态就移除这个worker。数据相关常见于数据不均匀，这个不好从worker并发角度去解决，出现这种情况时需要分析一下造成数据不均匀的问题然后重新对数据进行打散。
